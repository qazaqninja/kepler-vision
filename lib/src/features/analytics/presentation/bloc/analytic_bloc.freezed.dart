// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'analytic_bloc.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$AnalyticEvent {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticEventCopyWith<$Res> {
  factory $AnalyticEventCopyWith(
          AnalyticEvent value, $Res Function(AnalyticEvent) then) =
      _$AnalyticEventCopyWithImpl<$Res, AnalyticEvent>;
}

/// @nodoc
class _$AnalyticEventCopyWithImpl<$Res, $Val extends AnalyticEvent>
    implements $AnalyticEventCopyWith<$Res> {
  _$AnalyticEventCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$StartedImplCopyWith<$Res> {
  factory _$$StartedImplCopyWith(
          _$StartedImpl value, $Res Function(_$StartedImpl) then) =
      __$$StartedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$StartedImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$StartedImpl>
    implements _$$StartedImplCopyWith<$Res> {
  __$$StartedImplCopyWithImpl(
      _$StartedImpl _value, $Res Function(_$StartedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$StartedImpl with DiagnosticableTreeMixin implements _Started {
  const _$StartedImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.started()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'AnalyticEvent.started'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$StartedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return started();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return started?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return started(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return started?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (started != null) {
      return started(this);
    }
    return orElse();
  }
}

abstract class _Started implements AnalyticEvent {
  const factory _Started() = _$StartedImpl;
}

/// @nodoc
abstract class _$$GetEventCountImplCopyWith<$Res> {
  factory _$$GetEventCountImplCopyWith(
          _$GetEventCountImpl value, $Res Function(_$GetEventCountImpl) then) =
      __$$GetEventCountImplCopyWithImpl<$Res>;
  @useResult
  $Res call({GetEventsCountRequest request});

  $GetEventsCountRequestCopyWith<$Res> get request;
}

/// @nodoc
class __$$GetEventCountImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$GetEventCountImpl>
    implements _$$GetEventCountImplCopyWith<$Res> {
  __$$GetEventCountImplCopyWithImpl(
      _$GetEventCountImpl _value, $Res Function(_$GetEventCountImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? request = null,
  }) {
    return _then(_$GetEventCountImpl(
      null == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as GetEventsCountRequest,
    ));
  }

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetEventsCountRequestCopyWith<$Res> get request {
    return $GetEventsCountRequestCopyWith<$Res>(_value.request, (value) {
      return _then(_value.copyWith(request: value));
    });
  }
}

/// @nodoc

class _$GetEventCountImpl
    with DiagnosticableTreeMixin
    implements _GetEventCount {
  const _$GetEventCountImpl(this.request);

  @override
  final GetEventsCountRequest request;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.getEventsCount(request: $request)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticEvent.getEventsCount'))
      ..add(DiagnosticsProperty('request', request));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetEventCountImpl &&
            (identical(other.request, request) || other.request == request));
  }

  @override
  int get hashCode => Object.hash(runtimeType, request);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GetEventCountImplCopyWith<_$GetEventCountImpl> get copyWith =>
      __$$GetEventCountImplCopyWithImpl<_$GetEventCountImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return getEventsCount(request);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return getEventsCount?.call(request);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (getEventsCount != null) {
      return getEventsCount(request);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return getEventsCount(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return getEventsCount?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (getEventsCount != null) {
      return getEventsCount(this);
    }
    return orElse();
  }
}

abstract class _GetEventCount implements AnalyticEvent {
  const factory _GetEventCount(final GetEventsCountRequest request) =
      _$GetEventCountImpl;

  GetEventsCountRequest get request;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GetEventCountImplCopyWith<_$GetEventCountImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ChangeDateFilterImplCopyWith<$Res> {
  factory _$$ChangeDateFilterImplCopyWith(_$ChangeDateFilterImpl value,
          $Res Function(_$ChangeDateFilterImpl) then) =
      __$$ChangeDateFilterImplCopyWithImpl<$Res>;
  @useResult
  $Res call({DateFilter dateFilter});

  $DateFilterCopyWith<$Res> get dateFilter;
}

/// @nodoc
class __$$ChangeDateFilterImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$ChangeDateFilterImpl>
    implements _$$ChangeDateFilterImplCopyWith<$Res> {
  __$$ChangeDateFilterImplCopyWithImpl(_$ChangeDateFilterImpl _value,
      $Res Function(_$ChangeDateFilterImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? dateFilter = null,
  }) {
    return _then(_$ChangeDateFilterImpl(
      null == dateFilter
          ? _value.dateFilter
          : dateFilter // ignore: cast_nullable_to_non_nullable
              as DateFilter,
    ));
  }

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateFilterCopyWith<$Res> get dateFilter {
    return $DateFilterCopyWith<$Res>(_value.dateFilter, (value) {
      return _then(_value.copyWith(dateFilter: value));
    });
  }
}

/// @nodoc

class _$ChangeDateFilterImpl
    with DiagnosticableTreeMixin
    implements _ChangeDateFilter {
  const _$ChangeDateFilterImpl(this.dateFilter);

  @override
  final DateFilter dateFilter;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.changeDateFilter(dateFilter: $dateFilter)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticEvent.changeDateFilter'))
      ..add(DiagnosticsProperty('dateFilter', dateFilter));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ChangeDateFilterImpl &&
            (identical(other.dateFilter, dateFilter) ||
                other.dateFilter == dateFilter));
  }

  @override
  int get hashCode => Object.hash(runtimeType, dateFilter);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ChangeDateFilterImplCopyWith<_$ChangeDateFilterImpl> get copyWith =>
      __$$ChangeDateFilterImplCopyWithImpl<_$ChangeDateFilterImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return changeDateFilter(dateFilter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return changeDateFilter?.call(dateFilter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (changeDateFilter != null) {
      return changeDateFilter(dateFilter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return changeDateFilter(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return changeDateFilter?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (changeDateFilter != null) {
      return changeDateFilter(this);
    }
    return orElse();
  }
}

abstract class _ChangeDateFilter implements AnalyticEvent {
  const factory _ChangeDateFilter(final DateFilter dateFilter) =
      _$ChangeDateFilterImpl;

  DateFilter get dateFilter;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ChangeDateFilterImplCopyWith<_$ChangeDateFilterImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetHotSpotsImplCopyWith<$Res> {
  factory _$$GetHotSpotsImplCopyWith(
          _$GetHotSpotsImpl value, $Res Function(_$GetHotSpotsImpl) then) =
      __$$GetHotSpotsImplCopyWithImpl<$Res>;
  @useResult
  $Res call({GetHotSpotsRequest request});

  $GetHotSpotsRequestCopyWith<$Res> get request;
}

/// @nodoc
class __$$GetHotSpotsImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$GetHotSpotsImpl>
    implements _$$GetHotSpotsImplCopyWith<$Res> {
  __$$GetHotSpotsImplCopyWithImpl(
      _$GetHotSpotsImpl _value, $Res Function(_$GetHotSpotsImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? request = null,
  }) {
    return _then(_$GetHotSpotsImpl(
      null == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as GetHotSpotsRequest,
    ));
  }

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetHotSpotsRequestCopyWith<$Res> get request {
    return $GetHotSpotsRequestCopyWith<$Res>(_value.request, (value) {
      return _then(_value.copyWith(request: value));
    });
  }
}

/// @nodoc

class _$GetHotSpotsImpl with DiagnosticableTreeMixin implements _GetHotSpots {
  const _$GetHotSpotsImpl(this.request);

  @override
  final GetHotSpotsRequest request;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.getHotSpots(request: $request)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticEvent.getHotSpots'))
      ..add(DiagnosticsProperty('request', request));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetHotSpotsImpl &&
            (identical(other.request, request) || other.request == request));
  }

  @override
  int get hashCode => Object.hash(runtimeType, request);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GetHotSpotsImplCopyWith<_$GetHotSpotsImpl> get copyWith =>
      __$$GetHotSpotsImplCopyWithImpl<_$GetHotSpotsImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return getHotSpots(request);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return getHotSpots?.call(request);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (getHotSpots != null) {
      return getHotSpots(request);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return getHotSpots(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return getHotSpots?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (getHotSpots != null) {
      return getHotSpots(this);
    }
    return orElse();
  }
}

abstract class _GetHotSpots implements AnalyticEvent {
  const factory _GetHotSpots(final GetHotSpotsRequest request) =
      _$GetHotSpotsImpl;

  GetHotSpotsRequest get request;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GetHotSpotsImplCopyWith<_$GetHotSpotsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$GetProblemClassesImplCopyWith<$Res> {
  factory _$$GetProblemClassesImplCopyWith(_$GetProblemClassesImpl value,
          $Res Function(_$GetProblemClassesImpl) then) =
      __$$GetProblemClassesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({GetProblemClassesRequest request});

  $GetProblemClassesRequestCopyWith<$Res> get request;
}

/// @nodoc
class __$$GetProblemClassesImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$GetProblemClassesImpl>
    implements _$$GetProblemClassesImplCopyWith<$Res> {
  __$$GetProblemClassesImplCopyWithImpl(_$GetProblemClassesImpl _value,
      $Res Function(_$GetProblemClassesImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? request = null,
  }) {
    return _then(_$GetProblemClassesImpl(
      null == request
          ? _value.request
          : request // ignore: cast_nullable_to_non_nullable
              as GetProblemClassesRequest,
    ));
  }

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetProblemClassesRequestCopyWith<$Res> get request {
    return $GetProblemClassesRequestCopyWith<$Res>(_value.request, (value) {
      return _then(_value.copyWith(request: value));
    });
  }
}

/// @nodoc

class _$GetProblemClassesImpl
    with DiagnosticableTreeMixin
    implements _GetProblemClasses {
  const _$GetProblemClassesImpl(this.request);

  @override
  final GetProblemClassesRequest request;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.getProblemClasses(request: $request)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticEvent.getProblemClasses'))
      ..add(DiagnosticsProperty('request', request));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$GetProblemClassesImpl &&
            (identical(other.request, request) || other.request == request));
  }

  @override
  int get hashCode => Object.hash(runtimeType, request);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$GetProblemClassesImplCopyWith<_$GetProblemClassesImpl> get copyWith =>
      __$$GetProblemClassesImplCopyWithImpl<_$GetProblemClassesImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return getProblemClasses(request);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return getProblemClasses?.call(request);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (getProblemClasses != null) {
      return getProblemClasses(request);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return getProblemClasses(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return getProblemClasses?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (getProblemClasses != null) {
      return getProblemClasses(this);
    }
    return orElse();
  }
}

abstract class _GetProblemClasses implements AnalyticEvent {
  const factory _GetProblemClasses(final GetProblemClassesRequest request) =
      _$GetProblemClassesImpl;

  GetProblemClassesRequest get request;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$GetProblemClassesImplCopyWith<_$GetProblemClassesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$LoadAllDataImplCopyWith<$Res> {
  factory _$$LoadAllDataImplCopyWith(
          _$LoadAllDataImpl value, $Res Function(_$LoadAllDataImpl) then) =
      __$$LoadAllDataImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String schoolId, DateFilter? dateFilter});

  $DateFilterCopyWith<$Res>? get dateFilter;
}

/// @nodoc
class __$$LoadAllDataImplCopyWithImpl<$Res>
    extends _$AnalyticEventCopyWithImpl<$Res, _$LoadAllDataImpl>
    implements _$$LoadAllDataImplCopyWith<$Res> {
  __$$LoadAllDataImplCopyWithImpl(
      _$LoadAllDataImpl _value, $Res Function(_$LoadAllDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? schoolId = null,
    Object? dateFilter = freezed,
  }) {
    return _then(_$LoadAllDataImpl(
      schoolId: null == schoolId
          ? _value.schoolId
          : schoolId // ignore: cast_nullable_to_non_nullable
              as String,
      dateFilter: freezed == dateFilter
          ? _value.dateFilter
          : dateFilter // ignore: cast_nullable_to_non_nullable
              as DateFilter?,
    ));
  }

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateFilterCopyWith<$Res>? get dateFilter {
    if (_value.dateFilter == null) {
      return null;
    }

    return $DateFilterCopyWith<$Res>(_value.dateFilter!, (value) {
      return _then(_value.copyWith(dateFilter: value));
    });
  }
}

/// @nodoc

class _$LoadAllDataImpl with DiagnosticableTreeMixin implements _LoadAllData {
  const _$LoadAllDataImpl({required this.schoolId, this.dateFilter});

  @override
  final String schoolId;
  @override
  final DateFilter? dateFilter;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticEvent.loadAllData(schoolId: $schoolId, dateFilter: $dateFilter)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticEvent.loadAllData'))
      ..add(DiagnosticsProperty('schoolId', schoolId))
      ..add(DiagnosticsProperty('dateFilter', dateFilter));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadAllDataImpl &&
            (identical(other.schoolId, schoolId) ||
                other.schoolId == schoolId) &&
            (identical(other.dateFilter, dateFilter) ||
                other.dateFilter == dateFilter));
  }

  @override
  int get hashCode => Object.hash(runtimeType, schoolId, dateFilter);

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadAllDataImplCopyWith<_$LoadAllDataImpl> get copyWith =>
      __$$LoadAllDataImplCopyWithImpl<_$LoadAllDataImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() started,
    required TResult Function(GetEventsCountRequest request) getEventsCount,
    required TResult Function(DateFilter dateFilter) changeDateFilter,
    required TResult Function(GetHotSpotsRequest request) getHotSpots,
    required TResult Function(GetProblemClassesRequest request)
        getProblemClasses,
    required TResult Function(String schoolId, DateFilter? dateFilter)
        loadAllData,
  }) {
    return loadAllData(schoolId, dateFilter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? started,
    TResult? Function(GetEventsCountRequest request)? getEventsCount,
    TResult? Function(DateFilter dateFilter)? changeDateFilter,
    TResult? Function(GetHotSpotsRequest request)? getHotSpots,
    TResult? Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult? Function(String schoolId, DateFilter? dateFilter)? loadAllData,
  }) {
    return loadAllData?.call(schoolId, dateFilter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? started,
    TResult Function(GetEventsCountRequest request)? getEventsCount,
    TResult Function(DateFilter dateFilter)? changeDateFilter,
    TResult Function(GetHotSpotsRequest request)? getHotSpots,
    TResult Function(GetProblemClassesRequest request)? getProblemClasses,
    TResult Function(String schoolId, DateFilter? dateFilter)? loadAllData,
    required TResult orElse(),
  }) {
    if (loadAllData != null) {
      return loadAllData(schoolId, dateFilter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Started value) started,
    required TResult Function(_GetEventCount value) getEventsCount,
    required TResult Function(_ChangeDateFilter value) changeDateFilter,
    required TResult Function(_GetHotSpots value) getHotSpots,
    required TResult Function(_GetProblemClasses value) getProblemClasses,
    required TResult Function(_LoadAllData value) loadAllData,
  }) {
    return loadAllData(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Started value)? started,
    TResult? Function(_GetEventCount value)? getEventsCount,
    TResult? Function(_ChangeDateFilter value)? changeDateFilter,
    TResult? Function(_GetHotSpots value)? getHotSpots,
    TResult? Function(_GetProblemClasses value)? getProblemClasses,
    TResult? Function(_LoadAllData value)? loadAllData,
  }) {
    return loadAllData?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Started value)? started,
    TResult Function(_GetEventCount value)? getEventsCount,
    TResult Function(_ChangeDateFilter value)? changeDateFilter,
    TResult Function(_GetHotSpots value)? getHotSpots,
    TResult Function(_GetProblemClasses value)? getProblemClasses,
    TResult Function(_LoadAllData value)? loadAllData,
    required TResult orElse(),
  }) {
    if (loadAllData != null) {
      return loadAllData(this);
    }
    return orElse();
  }
}

abstract class _LoadAllData implements AnalyticEvent {
  const factory _LoadAllData(
      {required final String schoolId,
      final DateFilter? dateFilter}) = _$LoadAllDataImpl;

  String get schoolId;
  DateFilter? get dateFilter;

  /// Create a copy of AnalyticEvent
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadAllDataImplCopyWith<_$LoadAllDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnalyticState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(AnalyticViewModel viewModel) loaded,
    required TResult Function(String error) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(AnalyticViewModel viewModel)? loaded,
    TResult? Function(String error)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(AnalyticViewModel viewModel)? loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticStateCopyWith<$Res> {
  factory $AnalyticStateCopyWith(
          AnalyticState value, $Res Function(AnalyticState) then) =
      _$AnalyticStateCopyWithImpl<$Res, AnalyticState>;
}

/// @nodoc
class _$AnalyticStateCopyWithImpl<$Res, $Val extends AnalyticState>
    implements $AnalyticStateCopyWith<$Res> {
  _$AnalyticStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$AnalyticStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc

class _$LoadingImpl with DiagnosticableTreeMixin implements _Loading {
  const _$LoadingImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticState.loading()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'AnalyticState.loading'));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(AnalyticViewModel viewModel) loaded,
    required TResult Function(String error) error,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(AnalyticViewModel viewModel)? loaded,
    TResult? Function(String error)? error,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(AnalyticViewModel viewModel)? loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements AnalyticState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({AnalyticViewModel viewModel});

  $AnalyticViewModelCopyWith<$Res> get viewModel;
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$AnalyticStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? viewModel = null,
  }) {
    return _then(_$LoadedImpl(
      viewModel: null == viewModel
          ? _value.viewModel
          : viewModel // ignore: cast_nullable_to_non_nullable
              as AnalyticViewModel,
    ));
  }

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $AnalyticViewModelCopyWith<$Res> get viewModel {
    return $AnalyticViewModelCopyWith<$Res>(_value.viewModel, (value) {
      return _then(_value.copyWith(viewModel: value));
    });
  }
}

/// @nodoc

class _$LoadedImpl with DiagnosticableTreeMixin implements _Loaded {
  const _$LoadedImpl({required this.viewModel});

  @override
  final AnalyticViewModel viewModel;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticState.loaded(viewModel: $viewModel)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticState.loaded'))
      ..add(DiagnosticsProperty('viewModel', viewModel));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            (identical(other.viewModel, viewModel) ||
                other.viewModel == viewModel));
  }

  @override
  int get hashCode => Object.hash(runtimeType, viewModel);

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(AnalyticViewModel viewModel) loaded,
    required TResult Function(String error) error,
  }) {
    return loaded(viewModel);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(AnalyticViewModel viewModel)? loaded,
    TResult? Function(String error)? error,
  }) {
    return loaded?.call(viewModel);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(AnalyticViewModel viewModel)? loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(viewModel);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements AnalyticState {
  const factory _Loaded({required final AnalyticViewModel viewModel}) =
      _$LoadedImpl;

  AnalyticViewModel get viewModel;

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String error});
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$AnalyticStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? error = null,
  }) {
    return _then(_$ErrorImpl(
      null == error
          ? _value.error
          : error // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ErrorImpl with DiagnosticableTreeMixin implements _Error {
  const _$ErrorImpl(this.error);

  @override
  final String error;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticState.error(error: $error)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticState.error'))
      ..add(DiagnosticsProperty('error', error));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.error, error) || other.error == error));
  }

  @override
  int get hashCode => Object.hash(runtimeType, error);

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() loading,
    required TResult Function(AnalyticViewModel viewModel) loaded,
    required TResult Function(String error) error,
  }) {
    return error(this.error);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? loading,
    TResult? Function(AnalyticViewModel viewModel)? loaded,
    TResult? Function(String error)? error,
  }) {
    return error?.call(this.error);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? loading,
    TResult Function(AnalyticViewModel viewModel)? loaded,
    TResult Function(String error)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this.error);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements AnalyticState {
  const factory _Error(final String error) = _$ErrorImpl;

  String get error;

  /// Create a copy of AnalyticState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$AnalyticViewModel {
  GetAnalyticsEntity? get analytics => throw _privateConstructorUsedError;
  DateFilter? get analyticsDateFilter => throw _privateConstructorUsedError;
  GetHotSpotsEntity? get hotSpots => throw _privateConstructorUsedError;
  GetProblemClassesEntity? get problemClasses =>
      throw _privateConstructorUsedError;

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $AnalyticViewModelCopyWith<AnalyticViewModel> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $AnalyticViewModelCopyWith<$Res> {
  factory $AnalyticViewModelCopyWith(
          AnalyticViewModel value, $Res Function(AnalyticViewModel) then) =
      _$AnalyticViewModelCopyWithImpl<$Res, AnalyticViewModel>;
  @useResult
  $Res call(
      {GetAnalyticsEntity? analytics,
      DateFilter? analyticsDateFilter,
      GetHotSpotsEntity? hotSpots,
      GetProblemClassesEntity? problemClasses});

  $GetAnalyticsEntityCopyWith<$Res>? get analytics;
  $DateFilterCopyWith<$Res>? get analyticsDateFilter;
  $GetHotSpotsEntityCopyWith<$Res>? get hotSpots;
  $GetProblemClassesEntityCopyWith<$Res>? get problemClasses;
}

/// @nodoc
class _$AnalyticViewModelCopyWithImpl<$Res, $Val extends AnalyticViewModel>
    implements $AnalyticViewModelCopyWith<$Res> {
  _$AnalyticViewModelCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? analytics = freezed,
    Object? analyticsDateFilter = freezed,
    Object? hotSpots = freezed,
    Object? problemClasses = freezed,
  }) {
    return _then(_value.copyWith(
      analytics: freezed == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as GetAnalyticsEntity?,
      analyticsDateFilter: freezed == analyticsDateFilter
          ? _value.analyticsDateFilter
          : analyticsDateFilter // ignore: cast_nullable_to_non_nullable
              as DateFilter?,
      hotSpots: freezed == hotSpots
          ? _value.hotSpots
          : hotSpots // ignore: cast_nullable_to_non_nullable
              as GetHotSpotsEntity?,
      problemClasses: freezed == problemClasses
          ? _value.problemClasses
          : problemClasses // ignore: cast_nullable_to_non_nullable
              as GetProblemClassesEntity?,
    ) as $Val);
  }

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetAnalyticsEntityCopyWith<$Res>? get analytics {
    if (_value.analytics == null) {
      return null;
    }

    return $GetAnalyticsEntityCopyWith<$Res>(_value.analytics!, (value) {
      return _then(_value.copyWith(analytics: value) as $Val);
    });
  }

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $DateFilterCopyWith<$Res>? get analyticsDateFilter {
    if (_value.analyticsDateFilter == null) {
      return null;
    }

    return $DateFilterCopyWith<$Res>(_value.analyticsDateFilter!, (value) {
      return _then(_value.copyWith(analyticsDateFilter: value) as $Val);
    });
  }

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetHotSpotsEntityCopyWith<$Res>? get hotSpots {
    if (_value.hotSpots == null) {
      return null;
    }

    return $GetHotSpotsEntityCopyWith<$Res>(_value.hotSpots!, (value) {
      return _then(_value.copyWith(hotSpots: value) as $Val);
    });
  }

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $GetProblemClassesEntityCopyWith<$Res>? get problemClasses {
    if (_value.problemClasses == null) {
      return null;
    }

    return $GetProblemClassesEntityCopyWith<$Res>(_value.problemClasses!,
        (value) {
      return _then(_value.copyWith(problemClasses: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$AnalyticViewModelImplCopyWith<$Res>
    implements $AnalyticViewModelCopyWith<$Res> {
  factory _$$AnalyticViewModelImplCopyWith(_$AnalyticViewModelImpl value,
          $Res Function(_$AnalyticViewModelImpl) then) =
      __$$AnalyticViewModelImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {GetAnalyticsEntity? analytics,
      DateFilter? analyticsDateFilter,
      GetHotSpotsEntity? hotSpots,
      GetProblemClassesEntity? problemClasses});

  @override
  $GetAnalyticsEntityCopyWith<$Res>? get analytics;
  @override
  $DateFilterCopyWith<$Res>? get analyticsDateFilter;
  @override
  $GetHotSpotsEntityCopyWith<$Res>? get hotSpots;
  @override
  $GetProblemClassesEntityCopyWith<$Res>? get problemClasses;
}

/// @nodoc
class __$$AnalyticViewModelImplCopyWithImpl<$Res>
    extends _$AnalyticViewModelCopyWithImpl<$Res, _$AnalyticViewModelImpl>
    implements _$$AnalyticViewModelImplCopyWith<$Res> {
  __$$AnalyticViewModelImplCopyWithImpl(_$AnalyticViewModelImpl _value,
      $Res Function(_$AnalyticViewModelImpl) _then)
      : super(_value, _then);

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? analytics = freezed,
    Object? analyticsDateFilter = freezed,
    Object? hotSpots = freezed,
    Object? problemClasses = freezed,
  }) {
    return _then(_$AnalyticViewModelImpl(
      analytics: freezed == analytics
          ? _value.analytics
          : analytics // ignore: cast_nullable_to_non_nullable
              as GetAnalyticsEntity?,
      analyticsDateFilter: freezed == analyticsDateFilter
          ? _value.analyticsDateFilter
          : analyticsDateFilter // ignore: cast_nullable_to_non_nullable
              as DateFilter?,
      hotSpots: freezed == hotSpots
          ? _value.hotSpots
          : hotSpots // ignore: cast_nullable_to_non_nullable
              as GetHotSpotsEntity?,
      problemClasses: freezed == problemClasses
          ? _value.problemClasses
          : problemClasses // ignore: cast_nullable_to_non_nullable
              as GetProblemClassesEntity?,
    ));
  }
}

/// @nodoc

class _$AnalyticViewModelImpl
    with DiagnosticableTreeMixin
    implements _AnalyticViewModel {
  _$AnalyticViewModelImpl(
      {this.analytics,
      this.analyticsDateFilter,
      this.hotSpots,
      this.problemClasses});

  @override
  final GetAnalyticsEntity? analytics;
  @override
  final DateFilter? analyticsDateFilter;
  @override
  final GetHotSpotsEntity? hotSpots;
  @override
  final GetProblemClassesEntity? problemClasses;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'AnalyticViewModel(analytics: $analytics, analyticsDateFilter: $analyticsDateFilter, hotSpots: $hotSpots, problemClasses: $problemClasses)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'AnalyticViewModel'))
      ..add(DiagnosticsProperty('analytics', analytics))
      ..add(DiagnosticsProperty('analyticsDateFilter', analyticsDateFilter))
      ..add(DiagnosticsProperty('hotSpots', hotSpots))
      ..add(DiagnosticsProperty('problemClasses', problemClasses));
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$AnalyticViewModelImpl &&
            (identical(other.analytics, analytics) ||
                other.analytics == analytics) &&
            (identical(other.analyticsDateFilter, analyticsDateFilter) ||
                other.analyticsDateFilter == analyticsDateFilter) &&
            (identical(other.hotSpots, hotSpots) ||
                other.hotSpots == hotSpots) &&
            (identical(other.problemClasses, problemClasses) ||
                other.problemClasses == problemClasses));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, analytics, analyticsDateFilter, hotSpots, problemClasses);

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$AnalyticViewModelImplCopyWith<_$AnalyticViewModelImpl> get copyWith =>
      __$$AnalyticViewModelImplCopyWithImpl<_$AnalyticViewModelImpl>(
          this, _$identity);
}

abstract class _AnalyticViewModel implements AnalyticViewModel {
  factory _AnalyticViewModel(
      {final GetAnalyticsEntity? analytics,
      final DateFilter? analyticsDateFilter,
      final GetHotSpotsEntity? hotSpots,
      final GetProblemClassesEntity? problemClasses}) = _$AnalyticViewModelImpl;

  @override
  GetAnalyticsEntity? get analytics;
  @override
  DateFilter? get analyticsDateFilter;
  @override
  GetHotSpotsEntity? get hotSpots;
  @override
  GetProblemClassesEntity? get problemClasses;

  /// Create a copy of AnalyticViewModel
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$AnalyticViewModelImplCopyWith<_$AnalyticViewModelImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
